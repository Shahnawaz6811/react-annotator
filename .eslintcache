[{"/Users/shahn/dev/annotator/custom_annotator/src/Annotator/src/Annotator/reducers/general-reducer.js":"1","/Users/shahn/dev/annotator/custom_annotator/src/Annotator/src/ImageCanvas/index.js":"2","/Users/shahn/dev/annotator/custom_annotator/src/Annotator/src/RegionSelectAndTransformBoxes/index.js":"3","/Users/shahn/dev/annotator/custom_annotator/src/Annotator/src/MainLayout/index.js":"4","/Users/shahn/dev/annotator/custom_annotator/src/Annotator/src/ImageCanvas/use-mouse.js":"5"},{"size":34508,"mtime":1607068894333,"results":"6","hashOfConfig":"7"},{"size":14177,"mtime":1607067794552,"results":"8","hashOfConfig":"7"},{"size":7134,"mtime":1607071154153,"results":"9","hashOfConfig":"7"},{"size":13875,"mtime":1607073128923,"results":"10","hashOfConfig":"7"},{"size":4613,"mtime":1607066771878,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"14"},"18saq4t",{"filePath":"15","messages":"16","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"19","messages":"20","errorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"21","messages":"22","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/shahn/dev/annotator/custom_annotator/src/Annotator/src/Annotator/reducers/general-reducer.js",["23","24","25","26","27","28","29","30","31","32","33","34","35","36","37"],"// @flow\nimport type { MainLayoutState, Action } from \"../../MainLayout/types\"\nimport { moveRegion } from \"../../ImageCanvas/region-tools.js\"\nimport Immutable,{ getIn, setIn, updateIn } from \"seamless-immutable\"\nimport moment from \"moment\"\nimport isEqual from \"lodash/isEqual\"\nimport getActiveImage from \"./get-active-image\"\nimport { saveToHistory } from \"./history-handler.js\"\nimport colors from \"../../colors\"\nimport fixTwisted from \"./fix-twisted\"\nimport convertExpandingLineToPolygon from \"./convert-expanding-line-to-polygon\"\nimport clamp from \"clamp\"\n\nimport getLandmarksWithTransform from \"../../utils/get-landmarks-with-transform\"\n\nconst getRandomId = () => Math.random().toString().split(\".\")[1]\n\nconst generalReducer = (state, action) => {\n  if (\n    state.allowedArea &&\n    state.selectedTool !== \"modify-allowed-area\" &&\n    [\"MOUSE_DOWN\", \"MOUSE_UP\", \"MOUSE_MOVE\"].includes(action.type)\n  ) {\n    const aa = state.allowedArea\n    action.x = clamp(action.x, aa.x, aa.x + aa.w)\n    action.y = clamp(action.y, aa.y, aa.y + aa.h)\n  }\n\n  if (action.type === \"ON_CLS_ADDED\" && action.cls && action.cls !== \"\") {\n    const oldRegionClsList = state.regionClsList\n    const newState = {\n      ...state,\n      regionClsList: oldRegionClsList.concat(action.cls),\n    }\n    return newState\n  }\n\n  // Throttle certain actions\n  if (action.type === \"MOUSE_MOVE\") {\n    if (Date.now() - ((state: any).lastMouseMoveCall || 0) < 16) return state\n    state = setIn(state, [\"lastMouseMoveCall\"], Date.now())\n  }\n  if (!action.type.includes(\"MOUSE\")) {\n    state = setIn(state, [\"lastAction\"], action)\n  }\n\n  const { currentImageIndex, pathToActiveImage, activeImage } = getActiveImage(\n    state\n  )\n\n  const getRegionIndex = (region) => {\n    const regionId =\n      typeof region === \"string\" || typeof region === \"number\"\n        ? region\n        : region.id\n    if (!activeImage) return null\n    const regionIndex = (activeImage.regions || []).findIndex(\n      (r) => r.id === regionId\n    )\n    return regionIndex === -1 ? null : regionIndex\n  }\n  const getRegion = (regionId) => {\n    if (!activeImage) return null\n    const regionIndex = getRegionIndex(regionId)\n    if (regionIndex === null) return [null, null]\n    const region = activeImage.regions[regionIndex]\n    return [region, regionIndex]\n  }\n  const modifyRegion = (regionId, obj) => {\n    const [region, regionIndex] = getRegion(regionId)\n    if (!region) return state\n    if (obj !== null) {\n      return setIn(state, [...pathToActiveImage, \"regions\", regionIndex], {\n        ...region,\n        ...obj,\n      })\n    } else {\n      // delete region\n      const regions = activeImage.regions\n      return setIn(\n        state,\n        [...pathToActiveImage, \"regions\"],\n        (regions || []).filter((r) => r.id !== region.id)\n      )\n    }\n  }\n  const unselectRegions = (state: MainLayoutState) => {\n    if (!activeImage) return state\n    return setIn(\n      state,\n      [...pathToActiveImage, \"regions\"],\n      (activeImage.regions || []).map((r) => ({\n        ...r,\n        highlighted: false,\n      }))\n    )\n  }\n\n  const closeEditors = (state: MainLayoutState) => {\n    if (currentImageIndex === null) return state\n    return setIn(\n      state,\n      [...pathToActiveImage, \"regions\"],\n      (activeImage.regions || []).map((r) => ({\n        ...r,\n        editingLabels: false,\n      }))\n    )\n  }\n\n  const setNewImage = (img: string | Object, index: number) => {\n    let { src, frameTime } = typeof img === \"object\" ? img : { src: img }\n    return setIn(\n      setIn(state, [\"selectedImage\"], index),\n      [\"selectedImageFrameTime\"],\n      frameTime\n    )\n  }\n\n  switch (action.type) {\n    case \"@@INIT\": {\n      return setIn(state, ['initState'], state);\n    }\n    case \"SELECT_IMAGE\": {\n      return setNewImage(action.image, action.imageIndex)\n    }\n    \n    case 'SELECT_LABEL': {\n      // console.log(\"State: \", state);\n      const selectedLabel = action.selectedLabel;\n      // console.log(selectedLabel);\n      return setIn(\n        state,\n        ['images', state.selectedImage, 'label'],selectedLabel\n      )\n    }\n\n    case \"CHANGE_REGION\": {\n      // console.log(\"ActionRegion:\", action.region);\n      const regionIndex = getRegionIndex(action.region)\n      if (regionIndex === null) return state\n      const oldRegion = activeImage.regions[regionIndex]\n      // console.log('OldRegion,', oldRegion);\n      // console.log('NewRegion,', action.region);\n      if (oldRegion.cls !== action.region.cls) {\n        state = saveToHistory(state, \"Change Region Classification\")\n        const clsIndex = state.regionClsList.indexOf(action.region.cls)\n        if (clsIndex !== -1) {\n          action.region.color = colors[clsIndex % colors.length]\n        }\n      }\n      if (!isEqual(oldRegion.tags, action.region.tags)) {\n        state = saveToHistory(state, \"Change Region Tags\")\n      }\n      return setIn(\n        state,\n        [...pathToActiveImage, \"regions\", regionIndex],\n        action.region\n      )\n    }\n    case \"CHANGE_LABEL\": {\n      const label = action.label;\n      if (!label || activeImage.regions.length === 0) {\n        return state;\n      }\n      \n\n      // Check if image has regions associated to this label\n      const hasRegions = [...(activeImage.regions || [])].find((r) => r.cls === label.cls);\n      if (!hasRegions) {\n        return state;\n      }\n      \n\n      const regions = [...(activeImage.regions || [])].map((r) => {\n        if (r.cls === label.cls) {\n          return ({\n            ...r,\n            visible: label.visible,\n            locked: label.locked\n          })\n        }\n        return r;\n      })\n\n     state = setIn(state, ['regionClsList'], state.regionClsList.map(regionLabel => {\n        if (regionLabel.cls === label.cls) {\n          return ({\n            ...regionLabel,\n            visible: label.visible,\n            locked: label.locked\n\n          })\n        }\n       return regionLabel;\n      }));\n\n\n      return setIn(state, [...pathToActiveImage, \"regions\"], regions)\n\n    }\n    case \"CHANGE_IMAGE\": {\n      if (!activeImage) return state\n      const { delta } = action\n      for (const key of Object.keys(delta)) {\n        if (key === \"cls\") saveToHistory(state, \"Change Image Class\")\n        if (key === \"tags\") saveToHistory(state, \"Change Image Tags\")\n        state = setIn(state, [...pathToActiveImage, key], delta[key])\n      }\n      return state\n    }\n    case \"SELECT_REGION\": {\n      const { region } = action\n      const regionIndex = getRegionIndex(action.region)\n      if (regionIndex === null) return state\n      const regions = [...(activeImage.regions || [])].map((r) => ({\n        ...r,\n        highlighted: r.id === region.id,\n        editingLabels: r.id === region.id,\n      }))\n      return setIn(state, [...pathToActiveImage, \"regions\"], regions)\n    }\n    case \"BEGIN_MOVE_POINT\": {\n      state = closeEditors(state)\n      return setIn(state, [\"mode\"], {\n        mode: \"MOVE_REGION\",\n        regionId: action.point.id,\n      })\n    }\n    case \"BEGIN_BOX_TRANSFORM\": {\n      const { box, directions } = action\n      state = closeEditors(state)\n      if (directions[0] === 0 && directions[1] === 0) {\n        return setIn(state, [\"mode\"], { mode: \"MOVE_REGION\", regionId: box.id })\n      } else {\n        return setIn(state, [\"mode\"], {\n          mode: \"RESIZE_BOX\",\n          regionId: box.id,\n          freedom: directions,\n          original: { x: box.x, y: box.y, w: box.w, h: box.h },\n        })\n      }\n    }\n    case \"BEGIN_MOVE_POLYGON_POINT\": {\n\n      const { polygon, pointIndex } = action\n      // console.log('Pindex: ', polygon);\n\n      state = closeEditors(state)\n      if (\n        state.mode &&\n        state.mode.mode === \"DRAW_POLYGON\" &&\n        pointIndex === 0\n      ) {\n        return setIn(\n          modifyRegion(polygon, {\n            points: polygon.points.slice(0, -1),\n            open: false,\n          }),\n          [\"mode\"],\n          null\n        )\n      }\n      // else {\n      //   state = saveToHistory(state, \"Move Polygon Point\")\n      // }\n      return setIn(state, [\"mode\"], {\n        mode: \"MOVE_POLYGON_POINT\",\n        regionId: polygon.id,\n        pointIndex,\n      })\n    }\n    case \"BEGIN_MOVE_KEYPOINT\": {\n      const { region, keypointId } = action\n      state = closeEditors(state)\n      state = saveToHistory(state, \"Move Keypoint\")\n      return setIn(state, [\"mode\"], {\n        mode: \"MOVE_KEYPOINT\",\n        regionId: region.id,\n        keypointId,\n      })\n    }\n    case \"ADD_POLYGON_POINT\": {\n      const { polygon, point, pointIndex } = action\n      const regionIndex = getRegionIndex(polygon)\n      // console.log(\"regionIndex\", regionIndex);\n      if (regionIndex === null) return state\n      const points = [...polygon.points]\n      points.splice(pointIndex, 0, point)\n      return setIn(state, [...pathToActiveImage, \"regions\", regionIndex], {\n        ...polygon,\n        points,\n      })\n    }\n    case \"MOUSE_MOVE\": {\n      const { x, y } = action\n\n      if (!state.mode) return state\n      if (!activeImage) return state\n      const { mouseDownAt } = state\n      switch (state.mode.mode) {\n        case \"MOVE_POLYGON_POINT\": {\n          const { pointIndex, regionId } = state.mode\n          const regionIndex = getRegionIndex(regionId)\n          if (regionIndex === null) return state\n          return setIn(\n            state,\n            [\n              ...pathToActiveImage,\n              \"regions\",\n              regionIndex,\n              \"points\",\n              pointIndex,\n            ],\n            [x, y]\n          )\n        }\n        case \"MOVE_KEYPOINT\": {\n          const { keypointId, regionId } = state.mode\n          const [region, regionIndex] = getRegion(regionId)\n          if (regionIndex === null) return state\n          return setIn(\n            state,\n            [\n              ...pathToActiveImage,\n              \"regions\",\n              regionIndex,\n              \"points\",\n              keypointId,\n            ],\n            { ...(region: any).points[keypointId], x, y }\n          )\n        }\n        case \"MOVE_REGION\": {\n          const { regionId } = state.mode\n          if (regionId === \"$$allowed_area\") {\n            const {\n              allowedArea: { w, h },\n            } = state\n            return setIn(state, [\"allowedArea\"], {\n              x: x - w / 2,\n              y: y - h / 2,\n              w,\n              h,\n            })\n          }\n          const regionIndex = getRegionIndex(regionId)\n          if (regionIndex === null) return state\n          return setIn(\n            state,\n            [...pathToActiveImage, \"regions\", regionIndex],\n            moveRegion(activeImage.regions[regionIndex], x, y)\n          )\n        }\n        case \"RESIZE_BOX\": {\n          const {\n            regionId,\n            freedom: [xFree, yFree],\n            original: { x: ox, y: oy, w: ow, h: oh },\n          } = state.mode\n\n          const dx = xFree === 0 ? ox : xFree === -1 ? Math.min(ox + ow, x) : ox\n          const dw =\n            xFree === 0\n              ? ow\n              : xFree === -1\n              ? ow + (ox - dx)\n              : Math.max(0, ow + (x - ox - ow))\n          const dy = yFree === 0 ? oy : yFree === -1 ? Math.min(oy + oh, y) : oy\n          const dh =\n            yFree === 0\n              ? oh\n              : yFree === -1\n              ? oh + (oy - dy)\n              : Math.max(0, oh + (y - oy - oh))\n\n          // determine if we should switch the freedom\n          if (dw <= 0.001) {\n            state = setIn(state, [\"mode\", \"freedom\"], [xFree * -1, yFree])\n          }\n          if (dh <= 0.001) {\n            state = setIn(state, [\"mode\", \"freedom\"], [xFree, yFree * -1])\n          }\n\n          if (regionId === \"$$allowed_area\") {\n            return setIn(state, [\"allowedArea\"], {\n              x: dx,\n              w: dw,\n              y: dy,\n              h: dh,\n            })\n          }\n\n          const regionIndex = getRegionIndex(regionId)\n          if (regionIndex === null) return state\n          const box = activeImage.regions[regionIndex]\n\n          return setIn(state, [...pathToActiveImage, \"regions\", regionIndex], {\n            ...box,\n            x: dx,\n            w: dw,\n            y: dy,\n            h: dh,\n          })\n        }\n        case \"RESIZE_KEYPOINTS\": {\n          const { regionId, landmarks, centerX, centerY } = state.mode\n          const distFromCenter = Math.sqrt(\n            (centerX - x) ** 2 + (centerY - y) ** 2\n          )\n          const scale = distFromCenter / 0.15\n          return modifyRegion(regionId, {\n            points: getLandmarksWithTransform({\n              landmarks,\n              center: { x: centerX, y: centerY },\n              scale,\n            }),\n          })\n        }\n        case \"DRAW_POLYGON\": {\n          // console.log('Draw pol')\n          const { regionId } = state.mode\n          const [region, regionIndex] = getRegion(regionId)\n          if (!region) return setIn(state, [\"mode\"], null)\n          return setIn(\n            state,\n            [\n              ...pathToActiveImage,\n              \"regions\",\n              regionIndex,\n              \"points\",\n              (region: any).points.length - 1,\n            ],\n            [x, y]\n          )\n        }\n        case \"DRAW_EXPANDING_LINE\": {\n          const { regionId } = state.mode\n          const [expandingLine, regionIndex] = getRegion(regionId)\n          if (!expandingLine) return state\n          const isMouseDown = Boolean(state.mouseDownAt)\n          if (isMouseDown) {\n            // If the mouse is down, set width/angle\n            const lastPoint = expandingLine.points.slice(-1)[0]\n            const mouseDistFromLastPoint = Math.sqrt(\n              (lastPoint.x - x) ** 2 + (lastPoint.y - y) ** 2\n            )\n            if (mouseDistFromLastPoint < 0.002 && !lastPoint.width) return state\n\n            const newState = setIn(\n              state,\n              [...pathToActiveImage, \"regions\", regionIndex, \"points\"],\n              expandingLine.points.slice(0, -1).concat([\n                {\n                  ...lastPoint,\n                  width: mouseDistFromLastPoint * 2,\n                  angle: Math.atan2(lastPoint.x - x, lastPoint.y - y),\n                },\n              ])\n            )\n            return newState\n          } else {\n            // If mouse is up, move the next candidate point\n            return setIn(\n              state,\n              [...pathToActiveImage, \"regions\", regionIndex],\n              {\n                ...expandingLine,\n                candidatePoint: { x, y },\n              }\n            )\n          }\n\n          return state\n        }\n        case \"SET_EXPANDING_LINE_WIDTH\": {\n          const { regionId } = state.mode\n          const [expandingLine, regionIndex] = getRegion(regionId)\n          if (!expandingLine) return state\n          const lastPoint = expandingLine.points.slice(-1)[0]\n          const { mouseDownAt } = state\n          return setIn(\n            state,\n            [...pathToActiveImage, \"regions\", regionIndex, \"expandingWidth\"],\n            Math.sqrt((lastPoint.x - x) ** 2 + (lastPoint.y - y) ** 2)\n          )\n        }\n        default:\n          return state\n      }\n    }\n    case \"MOUSE_DOWN\": {\n      if (!activeImage) return state\n      const { x, y } = action\n\n\n      state = setIn(state, [\"mouseDownAt\"], { x, y })\n      \n      if (state.mode) {\n        switch (state.mode.mode) {\n          case \"DRAW_POLYGON\": {\n            const [polygon, regionIndex] = getRegion(state.mode.regionId)\n            if (!polygon) break\n            return setIn(\n              state,\n              [...pathToActiveImage, \"regions\", regionIndex],\n              { ...polygon, points: polygon.points.concat([[x, y]]) }\n            )\n          }\n          case \"DRAW_EXPANDING_LINE\": {\n            const [expandingLine, regionIndex] = getRegion(state.mode.regionId)\n            if (!expandingLine) break\n            const lastPoint = expandingLine.points.slice(-1)[0]\n            if (\n              expandingLine.points.length > 1 &&\n              Math.sqrt((lastPoint.x - x) ** 2 + (lastPoint.y - y) ** 2) < 0.002\n            ) {\n              if (!lastPoint.width) {\n                return setIn(state, [\"mode\"], {\n                  mode: \"SET_EXPANDING_LINE_WIDTH\",\n                  regionId: state.mode.regionId,\n                })\n              } else {\n                return state\n                  .setIn(\n                    [...pathToActiveImage, \"regions\", regionIndex],\n                    convertExpandingLineToPolygon(expandingLine)\n                  )\n                  .setIn([\"mode\"], null)\n              }\n            }\n\n            // Create new point\n            return setIn(\n              state,\n              [...pathToActiveImage, \"regions\", regionIndex, \"points\"],\n              expandingLine.points.concat([{ x, y, angle: null, width: null }])\n            )\n          }\n          case \"SET_EXPANDING_LINE_WIDTH\": {\n            const [expandingLine, regionIndex] = getRegion(state.mode.regionId)\n            if (!expandingLine) break\n            const { expandingWidth } = expandingLine\n            return state\n              .setIn(\n                [...pathToActiveImage, \"regions\", regionIndex],\n                convertExpandingLineToPolygon({\n                  ...expandingLine,\n                  points: expandingLine.points.map((p) =>\n                    p.width ? p : { ...p, width: expandingWidth }\n                  ),\n                  expandingWidth: undefined,\n                })\n              )\n              .setIn([\"mode\"], null)\n          }\n          default:\n            break\n        }\n      }\n\n      let newRegion\n      if (!activeImage.label) {\n        return state;\n      }\n      let defaultRegionCls = activeImage.label.cls,\n        defaultRegionColor = activeImage.label.color\n      // if (activeImage && (activeImage.regions || []).length > 0) {\n      //   defaultRegionCls = activeImage.regions.slice(-1)[0].cls\n      //   const clsIndex = (state.regionClsList || []).indexOf(defaultRegionCls)\n      //   if (clsIndex !== -1) {\n      //     defaultRegionColor = colors[clsIndex % colors.length]\n      //   }\n      // }\n\n      switch (state.selectedTool) {\n        case \"create-point\": {\n          state = saveToHistory(state, \"Create Point\")\n          newRegion = {\n            type: \"point\",\n            x,\n            y,\n            highlighted: true,\n            editingLabels: true,\n            color: defaultRegionColor,\n            id: getRandomId(),\n            cls: defaultRegionCls,\n          }\n          break\n        }\n        case \"create-box\": {\n          state = saveToHistory(state, \"Create Box\")\n          newRegion = {\n            type: \"box\",\n            x: x,\n            y: y,\n            w: 0,\n            h: 0,\n            highlighted: true,\n            editingLabels: false,\n            color: defaultRegionColor,\n            cls: defaultRegionCls,\n            id: getRandomId(),\n          }\n          state = setIn(state, [\"mode\"], {\n            mode: \"RESIZE_BOX\",\n            editLabelEditorAfter: true,\n            regionId: newRegion.id,\n            freedom: [1, 1],\n            original: { x, y, w: newRegion.w, h: newRegion.h },\n            isNew: true,\n          })\n          break\n        }\n        case \"polygon\": {\n\n          if (state.mode && state.mode.mode === \"DRAW_POLYGON\") break\n          state = saveToHistory(state, \"Create Polygon\")\n          newRegion = {\n            type: \"polygon\",\n            points: [\n              [x, y],\n              [x, y],\n            ],\n            open: true,\n            highlighted: true,\n            color: defaultRegionColor,\n            cls: defaultRegionCls,\n            id: getRandomId(),\n          }\n          state = setIn(state, [\"mode\"], {\n            mode: \"DRAW_POLYGON\",\n            regionId: newRegion.id,\n          })\n          break\n        }\n        case \"create-expanding-line\": {\n          state = saveToHistory(state, \"Create Expanding Line\")\n          newRegion = {\n            type: \"expanding-line\",\n            unfinished: true,\n            points: [{ x, y, angle: null, width: null }],\n            open: true,\n            highlighted: true,\n            color: defaultRegionColor,\n            cls: defaultRegionCls,\n            id: getRandomId(),\n          }\n          state = setIn(state, [\"mode\"], {\n            mode: \"DRAW_EXPANDING_LINE\",\n            regionId: newRegion.id,\n          })\n          break\n        }\n        case \"create-keypoints\": {\n          state = saveToHistory(state, \"Create Keypoints\")\n          const [\n            [keypointsDefinitionId, { landmarks, connections }],\n          ] = (Object.entries(state.keypointDefinitions): any)\n\n          newRegion = {\n            type: \"keypoints\",\n            keypointsDefinitionId,\n            points: getLandmarksWithTransform({\n              landmarks,\n              center: { x, y },\n              scale: 1,\n            }),\n            highlighted: true,\n            editingLabels: false,\n            id: getRandomId(),\n          }\n          state = setIn(state, [\"mode\"], {\n            mode: \"RESIZE_KEYPOINTS\",\n            landmarks,\n            centerX: x,\n            centerY: y,\n            regionId: newRegion.id,\n            isNew: true,\n          })\n          break\n        }\n        default:\n          break\n      }\n\n      const regions = [...(getIn(state, pathToActiveImage).regions || [])]\n        .map((r) =>\n          setIn(r, [\"editingLabels\"], false).setIn([\"highlighted\"], false)\n        )\n        .concat(newRegion ? [newRegion] : [])\n\n      return setIn(state, [...pathToActiveImage, \"regions\"], regions)\n    }\n    case \"MOUSE_UP\": {\n      const { x, y } = action\n\n      const { mouseDownAt = { x, y } } = state\n      if (!state.mode) return state\n      state = setIn(state, [\"mouseDownAt\"], null)\n      switch (state.mode.mode) {\n        case \"RESIZE_BOX\": {\n          if (state.mode.isNew) {\n            if (\n              Math.abs(state.mode.original.x - x) < 0.002 ||\n              Math.abs(state.mode.original.y - y) < 0.002\n            ) {\n              return setIn(\n                modifyRegion(state.mode.regionId, null),\n                [\"mode\"],\n                null\n              )\n            }\n          }\n          if (state.mode.editLabelEditorAfter) {\n            return {\n              ...modifyRegion(state.mode.regionId, { editingLabels: true }),\n              mode: null,\n            }\n          }\n        }\n        case \"MOVE_REGION\":\n        case \"RESIZE_KEYPOINTS\":\n        case \"MOVE_POLYGON_POINT\": {\n          // console.log(\"Moveee\")\n          return { ...state, mode: null }\n        }\n        case \"MOVE_KEYPOINT\": {\n          return { ...state, mode: null }\n        }\n        case \"CREATE_POINT_LINE\": {\n          return state\n        }\n        case \"DRAW_EXPANDING_LINE\": {\n          // console.log(\"Drawinggg\");\n          const [expandingLine, regionIndex] = getRegion(state.mode.regionId)\n          if (!expandingLine) return state\n          let newExpandingLine = expandingLine\n          const lastPoint =\n            expandingLine.points.length !== 0\n              ? expandingLine.points.slice(-1)[0]\n              : mouseDownAt\n          let jointStart\n          if (expandingLine.points.length > 1) {\n            jointStart = expandingLine.points.slice(-2)[0]\n          } else {\n            jointStart = lastPoint\n          }\n          const mouseDistFromLastPoint = Math.sqrt(\n            (lastPoint.x - x) ** 2 + (lastPoint.y - y) ** 2\n          )\n          if (mouseDistFromLastPoint > 0.002) {\n            // The user is drawing has drawn the width for the last point\n            const newPoints = [...expandingLine.points]\n            for (let i = 0; i < newPoints.length - 1; i++) {\n              if (newPoints[i].width) continue\n              newPoints[i] = {\n                ...newPoints[i],\n                width: lastPoint.width,\n              }\n            }\n            newExpandingLine = setIn(\n              expandingLine,\n              [\"points\"],\n              fixTwisted(newPoints)\n            )\n          } else {\n            return state\n          }\n          return setIn(\n            state,\n            [...pathToActiveImage, \"regions\", regionIndex],\n            newExpandingLine\n          )\n        }\n        default:\n          return state\n      }\n    }\n\n    case \"UPDATE_IMAGE_CANVAS\": {\n      return setNewImage(\n        state.images[action.payload.position],\n        action.payload.position\n      )\n    }\n\n    case \"OPEN_REGION_EDITOR\": {\n      const { region } = action\n      const regionIndex = getRegionIndex(action.region)\n      if (regionIndex === null) return state\n      const newRegions = setIn(\n        activeImage.regions.map((r) => ({\n          ...r,\n          highlighted: false,\n          editingLabels: false,\n        })),\n        [regionIndex],\n        {\n          ...(activeImage.regions || [])[regionIndex],\n          highlighted: true,\n          editingLabels: true,\n        }\n      )\n      return setIn(state, [...pathToActiveImage, \"regions\"], newRegions)\n    }\n    case \"CLOSE_REGION_EDITOR\": {\n      const { region } = action\n      const regionIndex = getRegionIndex(action.region)\n      if (regionIndex === null) return state\n      return setIn(state, [...pathToActiveImage, \"regions\", regionIndex], {\n        ...(activeImage.regions || [])[regionIndex],\n        editingLabels: false,\n      })\n    }\n    case \"DELETE_REGION\": {\n      const regionIndex = getRegionIndex(action.region)\n      if (regionIndex === null) return state\n      return setIn(\n        state,\n        [...pathToActiveImage, \"regions\"],\n        (activeImage.regions || []).filter((r) => r.id !== action.region.id)\n      )\n    }\n    case \"DELETE_SELECTED_REGION\": {\n      return setIn(\n        state,\n        [...pathToActiveImage, \"regions\"],\n        (activeImage.regions || []).filter((r) => !r.highlighted)\n      )\n    }\n    case \"HEADER_BUTTON_CLICKED\": {\n      const buttonName = action.buttonName.toLowerCase()\n      switch (buttonName) {\n        case \"undo\": {\n          // console.log(\"Original State: \", state);\n          // Check if current image has active regions to undo\n          if (activeImage.regions && activeImage.regions.length > 0) {\n            // const lastRegionAddedToActiveImage = activeImage.regions[];\n\n            // get last region inserted to active image\n           let lastRegionAddedToActiveImage = getIn(state,\n            [...pathToActiveImage, \"regions\",activeImage.regions.length - 1])\n            // console.log('lastRegionAddedToActiveImage: ', lastRegionAddedToActiveImage);\n            // const currentRegions = Immutable.asMutable(activeImage.regions.splice(-1,1))\n\n            //Remove last region inserted to active image\n            state = \n            setIn(state,[...pathToActiveImage, \"regions\"], activeImage.regions.filter((element, index) => index < activeImage.regions.length - 1))\n\n            // console.log(\"After removing regions:\", state);  \n            \n             // Cache last active image region to historyCache\n            let historyCacheForActiveImage = getIn(state, ['historyCache', activeImage.name]);\n            if (historyCacheForActiveImage) {\n              historyCacheForActiveImage = Immutable.asMutable(historyCacheForActiveImage);\n              historyCacheForActiveImage.push(lastRegionAddedToActiveImage)\n            } else {\n              historyCacheForActiveImage = [];\n              historyCacheForActiveImage.push(lastRegionAddedToActiveImage)\n            }\n            state =  setIn(state, ['historyCache', activeImage.name], historyCacheForActiveImage);\n            // historyCache[activeImage.name] = \n            // console.log(\"Cachinggg\", state);\n            // state = setIn(state, ['historyCache'], state.historyCache.length], lastRegionAddedToActiveImage);\n            // console.log('HistoryCahce', historyCacheForActiveImage);\n            \n            //  state = setIn(state, ['historyCache',state.historyCache.length], currentStateToCache);\n            // console.log(\"State after caching current state :\", state);\n\n          }\n          return state;\n        }\n        case \"redo\": {\n          // console.log('redo: ');\n          // Check if we have regions in cache  to redo\n          if (state.historyCache && state.historyCache[activeImage.name] && state.historyCache[activeImage.name].length > 0) {\n            \n            // get last item inserted to history cache\n            // let lastRegionAddedToCache = getIn(state,\n            //   [\"historyCache\", state.historyCache.length - 1]);\n            let lastRegionAddedToCache = state.historyCache[activeImage.name][state.historyCache[activeImage.name].length - 1];\n\n            // remove last item from history cache.\n            state = \n            setIn(state,['historyCache',activeImage.name], state.historyCache[activeImage.name].filter((element, index) => index < state.historyCache[activeImage.name].length - 1))\n\n            // console.log(\"lastRegionAddedToCache\", lastRegionAddedToCache)\n            // redo active image regions with last item popped from history cache\n            state = \n            setIn(state,[...pathToActiveImage, \"regions\",activeImage.regions.length],  lastRegionAddedToCache)\n            // return state.historyCache[0];\n            // console.log(\"After redoing regions \", state);\n           \n          }\n          return state;\n          \n        }\n        case 'reset': {\n          // console.log('Before reset: ', state);\n          if (activeImage.regions && activeImage.regions.length > 0) {\n            let historyCacheForActiveImage = getIn(state, ['historyCache', activeImage.name]);\n            if (historyCacheForActiveImage && historyCacheForActiveImage.length > 0) {\n             // clear history cache for current image.\n            state = \n              setIn(state,['historyCache',activeImage.name], [])\n            }\n            state = \n              setIn(state,['historyCache',activeImage.name], activeImage.regions)\n\n            state = \n              setIn(state,\n                [...pathToActiveImage, \"regions\"],\n                [])\n          }\n          \n            // state = setIn(state.history[state.history.length - 1].state, ['history'], []);\n            // console.log(\"After reset\", state);\n          \n      \n          return state;\n        }\n        case \"prev\": {\n          if (currentImageIndex === null) return state\n          if (currentImageIndex === 0) return state\n          return setNewImage(\n            state.images[currentImageIndex - 1],\n            currentImageIndex - 1\n          )\n        }\n        case \"next\": {\n          if (currentImageIndex === null) return state\n          if (currentImageIndex === state.images.length - 1) return state\n          return setNewImage(\n            state.images[currentImageIndex + 1],\n            currentImageIndex + 1\n          )\n        }\n        \n        case \"clone\": {\n          if (currentImageIndex === null) return state\n          if (currentImageIndex === state.images.length - 1) return state\n          return setIn(\n            setNewImage(\n              state.images[currentImageIndex + 1],\n              currentImageIndex + 1\n            ),\n            [\"images\", currentImageIndex + 1, \"regions\"],\n            activeImage.regions\n          )\n        }\n        case \"settings\": {\n          return setIn(state, [\"settingsOpen\"], !state.settingsOpen)\n        }\n        case \"help\": {\n          return state\n        }\n        case \"fullscreen\": {\n          return setIn(state, [\"fullScreen\"], true)\n        }\n        case \"exit fullscreen\":\n        case \"window\": {\n          return setIn(state, [\"fullScreen\"], false)\n        }\n        case \"hotkeys\": {\n          return state\n        }\n        case \"exit\":\n        case \"done\": {\n          return state\n        }\n        default:\n          return state\n      }\n      break;\n    }\n   \n    case \"UPDATE_FILTER\": {\n        \n      // return setIn(state, [\"zoomOut\"], !state.zoomOut)\n      // console.log('Action:',action.payload.value);\n      let filter = getIn( state,\n        [...pathToActiveImage, \"filter\"])\n        if(!filter){\n          filter = {};\n          // filter['brightness'] = action.payload.value;\n       }\n      //  console.log('Payliad: ',filter);\n\n      const newState =  setIn(\n        state,\n        [...pathToActiveImage, \"filter\"],\n        {...filter,[action.payload.name]: action.payload.value}\n      )\n\n      return newState;\n        \n    }\n    case \"SELECT_TOOL\": {\n      // console.log(\"Action,\", action);\n      if(action.selectedTool === 'inverse') {\n       let filter = getIn( state,\n        [...pathToActiveImage, \"filter\"])\n       if(!filter){\n         filter = {};\n         filter.inverse = 0;\n       }\n      return  setIn(\n        state,\n        [...pathToActiveImage, \"filter\"],\n        {...filter,inverse: filter.inverse == 0 ? 100:0}\n      )      \n      }\n    \n       if (action.selectedTool === \"zoom-in\") {\n        return setIn(state, [\"zoomOut\"], !state.zoomOut)\n      }\n      if (action.selectedTool === \"modify-allowed-area\" && !state.allowedArea) {\n        state = setIn(state, [\"allowedArea\"], { x: 0, y: 0, w: 1, h: 1 })\n      }\n      state = setIn(state, [\"mode\"], null)\n      return setIn(state, [\"selectedTool\"], action.selectedTool)\n    }\n    case \"CANCEL\": {\n      const { mode } = state\n      if (mode) {\n        switch (mode.mode) {\n          case \"DRAW_EXPANDING_LINE\":\n          case \"SET_EXPANDING_LINE_WIDTH\":\n          case \"DRAW_POLYGON\": {\n            const { regionId } = mode\n            return modifyRegion(regionId, null)\n          }\n          case \"MOVE_POLYGON_POINT\":\n          case \"RESIZE_BOX\":\n          case \"MOVE_REGION\": {\n            return setIn(state, [\"mode\"], null)\n          }\n          default:\n            return state\n        }\n      }\n      // Close any open boxes\n      const regions: any = activeImage.regions\n      if (regions && regions.some((r) => r.editingLabels)) {\n        return setIn(\n          state,\n          [...pathToActiveImage, \"regions\"],\n          regions.map((r) => ({\n            ...r,\n            editingLabels: false,\n          }))\n        )\n      } else if (regions) {\n        return setIn(\n          state,\n          [...pathToActiveImage, \"regions\"],\n          regions.map((r) => ({\n            ...r,\n            highlighted: false,\n          }))\n        )\n      }\n      break\n    }\n    default:\n      break\n  }\n  return state\n}\n\n\nexport default generalReducer;","/Users/shahn/dev/annotator/custom_annotator/src/Annotator/src/ImageCanvas/index.js",["38","39","40","41","42","43","44","45"],"/Users/shahn/dev/annotator/custom_annotator/src/Annotator/src/RegionSelectAndTransformBoxes/index.js",[],"/Users/shahn/dev/annotator/custom_annotator/src/Annotator/src/MainLayout/index.js",["46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64"],"/Users/shahn/dev/annotator/custom_annotator/src/Annotator/src/ImageCanvas/use-mouse.js",["65"],{"ruleId":"66","severity":1,"message":"67","line":2,"column":32,"nodeType":"68","messageId":"69","endLine":2,"endColumn":38},{"ruleId":"66","severity":1,"message":"70","line":4,"column":34,"nodeType":"68","messageId":"69","endLine":4,"endColumn":42},{"ruleId":"66","severity":1,"message":"71","line":5,"column":8,"nodeType":"68","messageId":"69","endLine":5,"endColumn":14},{"ruleId":"66","severity":1,"message":"72","line":87,"column":9,"nodeType":"68","messageId":"69","endLine":87,"endColumn":24},{"ruleId":"66","severity":1,"message":"73","line":112,"column":11,"nodeType":"68","messageId":"69","endLine":112,"endColumn":14},{"ruleId":"66","severity":1,"message":"74","line":300,"column":15,"nodeType":"68","messageId":"69","endLine":300,"endColumn":26},{"ruleId":"75","severity":1,"message":"76","line":474,"column":11,"nodeType":"77","messageId":"78","endLine":474,"endColumn":23},{"ruleId":"66","severity":1,"message":"74","line":481,"column":19,"nodeType":"68","messageId":"69","endLine":481,"endColumn":30},{"ruleId":"66","severity":1,"message":"79","line":658,"column":50,"nodeType":"68","messageId":"69","endLine":658,"endColumn":61},{"ruleId":"80","severity":1,"message":"81","line":722,"column":9,"nodeType":"82","messageId":"83","endLine":722,"endColumn":28},{"ruleId":"66","severity":1,"message":"84","line":747,"column":13,"nodeType":"68","messageId":"69","endLine":747,"endColumn":23},{"ruleId":"66","severity":1,"message":"85","line":789,"column":15,"nodeType":"68","messageId":"69","endLine":789,"endColumn":21},{"ruleId":"66","severity":1,"message":"85","line":808,"column":15,"nodeType":"68","messageId":"69","endLine":808,"endColumn":21},{"ruleId":"75","severity":1,"message":"76","line":975,"column":7,"nodeType":"86","messageId":"78","endLine":975,"endColumn":13},{"ruleId":"87","severity":1,"message":"88","line":1011,"column":44,"nodeType":"89","messageId":"90","endLine":1011,"endColumn":46},{"ruleId":"66","severity":1,"message":"91","line":19,"column":3,"nodeType":"68","messageId":"69","endLine":19,"endColumn":22},{"ruleId":"66","severity":1,"message":"92","line":30,"column":8,"nodeType":"68","messageId":"69","endLine":30,"endColumn":18},{"ruleId":"66","severity":1,"message":"93","line":151,"column":10,"nodeType":"68","messageId":"69","endLine":151,"endColumn":26},{"ruleId":"66","severity":1,"message":"94","line":151,"column":28,"nodeType":"68","messageId":"69","endLine":151,"endColumn":50},{"ruleId":"66","severity":1,"message":"95","line":155,"column":9,"nodeType":"68","messageId":"69","endLine":155,"endColumn":19},{"ruleId":"66","severity":1,"message":"96","line":161,"column":38,"nodeType":"68","messageId":"69","endLine":161,"endColumn":44},{"ruleId":"97","severity":1,"message":"98","line":180,"column":49,"nodeType":"99","endLine":180,"endColumn":61,"suggestions":"100"},{"ruleId":"66","severity":1,"message":"101","line":182,"column":9,"nodeType":"68","messageId":"69","endLine":182,"endColumn":22},{"ruleId":"66","severity":1,"message":"102","line":10,"column":8,"nodeType":"68","messageId":"69","endLine":10,"endColumn":18},{"ruleId":"66","severity":1,"message":"103","line":14,"column":10,"nodeType":"68","messageId":"69","endLine":14,"endColumn":20},{"ruleId":"66","severity":1,"message":"104","line":20,"column":8,"nodeType":"68","messageId":"69","endLine":20,"endColumn":24},{"ruleId":"66","severity":1,"message":"105","line":22,"column":8,"nodeType":"68","messageId":"69","endLine":22,"endColumn":16},{"ruleId":"66","severity":1,"message":"106","line":23,"column":8,"nodeType":"68","messageId":"69","endLine":23,"endColumn":22},{"ruleId":"66","severity":1,"message":"107","line":24,"column":8,"nodeType":"68","messageId":"69","endLine":24,"endColumn":25},{"ruleId":"66","severity":1,"message":"108","line":25,"column":8,"nodeType":"68","messageId":"69","endLine":25,"endColumn":23},{"ruleId":"66","severity":1,"message":"109","line":26,"column":8,"nodeType":"68","messageId":"69","endLine":26,"endColumn":22},{"ruleId":"66","severity":1,"message":"110","line":28,"column":8,"nodeType":"68","messageId":"69","endLine":28,"endColumn":25},{"ruleId":"66","severity":1,"message":"111","line":31,"column":7,"nodeType":"68","messageId":"69","endLine":31,"endColumn":15},{"ruleId":"66","severity":1,"message":"112","line":34,"column":7,"nodeType":"68","messageId":"69","endLine":34,"endColumn":16},{"ruleId":"66","severity":1,"message":"113","line":66,"column":9,"nodeType":"68","messageId":"69","endLine":66,"endColumn":16},{"ruleId":"66","severity":1,"message":"114","line":68,"column":9,"nodeType":"68","messageId":"69","endLine":68,"endColumn":25},{"ruleId":"115","severity":1,"message":"116","line":82,"column":66,"nodeType":"117","messageId":"118","endLine":82,"endColumn":67},{"ruleId":"66","severity":1,"message":"119","line":100,"column":9,"nodeType":"68","messageId":"69","endLine":100,"endColumn":22},{"ruleId":"66","severity":1,"message":"120","line":102,"column":9,"nodeType":"68","messageId":"69","endLine":102,"endColumn":23},{"ruleId":"66","severity":1,"message":"121","line":106,"column":9,"nodeType":"68","messageId":"69","endLine":106,"endColumn":28},{"ruleId":"66","severity":1,"message":"122","line":235,"column":9,"nodeType":"68","messageId":"69","endLine":235,"endColumn":20},{"ruleId":"66","severity":1,"message":"123","line":236,"column":9,"nodeType":"68","messageId":"69","endLine":236,"endColumn":28},{"ruleId":"124","severity":1,"message":"125","line":8,"column":1,"nodeType":"126","endLine":171,"endColumn":2},"no-unused-vars","'Action' is defined but never used.","Identifier","unusedVar","'updateIn' is defined but never used.","'moment' is defined but never used.","'unselectRegions' is assigned a value but never used.","'src' is assigned a value but never used.","'mouseDownAt' is assigned a value but never used.","no-unreachable","Unreachable code.","ReturnStatement","unreachableCode","'connections' is assigned a value but never used.","no-fallthrough","Expected a 'break' statement before 'case'.","SwitchCase","case","'jointStart' is assigned a value but never used.","'region' is assigned a value but never used.","BreakStatement","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'KeypointsDefinition' is defined but never used.","'RegionTags' is defined but never used.","'maskImagesLoaded' is assigned a value but never used.","'changeMaskImagesLoaded' is assigned a value but never used.","'maskImages' is assigned a value but never used.","'zoomIn' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useLayoutEffect has missing dependencies: 'changeMat' and 'mat'. Either include them or remove the dependency array.","ArrayExpression",["127"],"'innerMousePos' is assigned a value but never used.","'classnames' is defined but never used.","'FullScreen' is defined but never used.","'KeyframeTimeline' is defined but never used.","'DebugBox' is defined but never used.","'TagsSidebarBox' is defined but never used.","'KeyframesSelector' is defined but never used.","'TaskDescription' is defined but never used.","'RegionSelector' is defined but never used.","'HistorySidebarBox' is defined but never used.","'emptyArr' is assigned a value but never used.","'HotkeyDiv' is assigned a value but never used.","'classes' is assigned a value but never used.","'fullScreenHandle' is assigned a value but never used.","no-sequences","Unexpected use of comma operator.","SequenceExpression","unexpectedCommaExpression","'isAVideoFrame' is assigned a value but never used.","'hotkeyHandlers' is assigned a value but never used.","'refocusOnMouseEvent' is assigned a value but never used.","'debugModeOn' is assigned a value but never used.","'nextImageHasRegions' is assigned a value but never used.","import/no-anonymous-default-export","Assign arrow function to a variable before exporting as module default","ExportDefaultDeclaration",{"desc":"128","fix":"129"},"Update the dependencies array to be: [changeMat, mat, windowSize]",{"range":"130","text":"131"},[5067,5079],"[changeMat, mat, windowSize]"]